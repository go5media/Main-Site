<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V1 Announcement Player (Voice Packs)</title>

    <style>
        /* Basic page styling */
        body {
            font-family: sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f4f4f4;
            max-width: 800px; /* Limit width for better readability */
            margin: 15px auto; /* Center the content with margin */
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }

        /* Button styling */
        button {
            display: block;
            margin: 25px auto; /* Increased margin */
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #5cb85c; /* Green */
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #4cae4c; /* Darker green on hover */
        }

        button:disabled {
            background-color: #cccccc; /* Grey out when disabled */
            cursor: not-allowed;
        }

        /* Status display box */
        #status {
            margin-top: 30px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            word-wrap: break-word; /* Prevent long status text overflowing */
        }

        #status p {
            margin: 8px 0; /* Spacing for status lines */
        }

        #status span {
            font-weight: bold;
            color: #007bff; /* Blue for dynamic parts */
        }

        /* Note box styling */
         .important-note {
             background-color: #fff3cd; /* Light yellow */
             border: 1px solid #ffeeba;
             color: #856404; /* Dark yellow text */
             padding: 15px;
             margin: 20px 0;
             border-radius: 5px;
             text-align: center;
        }

        /* Styles for control sections */
        .controls {
            background-color: #eee; /* Light grey background */
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 25px;
        }
         .controls h2 {
             margin-top: 0;
             margin-bottom: 15px;
             font-size: 1.2em;
             color: #333;
             border-bottom: 1px solid #ccc;
             padding-bottom: 10px;
         }

        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #ccc;
        }
        .control-group:last-child { /* No border for last group in a section */
             border-bottom: none;
             margin-bottom: 0;
             padding-bottom: 5px; /* Reduce padding slightly */
        }


        .control-group h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #555;
        }

        .control-group label, .voice-control label {
            display: inline-block;
            margin-right: 5px;
            margin-bottom: 10px;
            min-width: 80px; /* Adjust as needed */
            vertical-align: middle;
        }

         .control-group select, .voice-control select {
             padding: 6px 8px;
             min-width: 120px;
             margin-right: 20px;
             vertical-align: middle;
             border: 1px solid #ccc;
             border-radius: 4px;
             margin-bottom: 10px; /* Ensure space below selects */
         }
         .voice-control { /* Specific styling for voice controls */
             margin-bottom: 15px;
         }
         .voice-control label {
             min-width: 110px; /* Wider label for voice controls */
         }
    </style>
</head>
<body>

    <h1>Announcement Player</h1>

     <div class="important-note">
        <strong>Note:</strong> This version uses absolute paths (starting with /project1/). Small pauses between recordings may still occur. Audio files must be in subdirectories named '1' and '2' inside 'project1'.
    </div>

    <div class="controls">
        <h2>Voice Pack Selection</h2>
        <div class="voice-control">
             <label for="masterVoice">Master Voice:</label>
             <select id="masterVoice">
                 <option value="1" selected>Voice Pack 1</option>
                 <option value="2">Voice Pack 2</option>
             </select>
        </div>
        <div class="voice-control">
             <label for="rVoice">R Recordings Voice:</label>
             <select id="rVoice">
                 <option value="Master" selected>Use Master Voice</option>
                 <option value="1">Voice Pack 1</option>
                 <option value="2">Voice Pack 2</option>
             </select>
        </div>
         <div class="voice-control">
            <label for="nVoice">N Recordings Voice:</label>
            <select id="nVoice">
                <option value="Master" selected>Use Master Voice</option>
                <option value="1">Voice Pack 1</option>
                <option value="2">Voice Pack 2</option>
            </select>
        </div>
    </div>
    <div class="controls">
         <h2>Name Selection</h2>
        <div class="control-group">
            <h3>Legal Name Pair</h3>
            <label for="legalFirst">First Name:</label>
            <select id="legalFirst"></select>

            <label for="legalLast">Last Name:</label>
            <select id="legalLast"></select>
        </div>
        <div class="control-group">
            <h3>New Name Pair</h3>
            <label for="newFirst">First Name:</label>
            <select id="newFirst"></select>

            <label for="newLast">Last Name:</label>
            <select id="newLast"></select>
        </div>
    </div>
    <button id="playButton">Play Announcement</button>

    <div id="status">
        <p>Configure voices/names above and click the button to play.</p>
        <p><strong>Chosen Name Pairs:</strong> <span id="selectedNames"></span></p>
        <p><strong>Currently Playing:</strong> <span id="currentTrack">Idle</span></p>
    </div>

    <audio id="playerA" preload="auto"></audio>
    <audio id="playerB" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get UI Elements ---
            const playButton = document.getElementById('playButton');
            const statusSelectedNames = document.getElementById('selectedNames');
            const statusCurrentTrack = document.getElementById('currentTrack');
            const playerA = document.getElementById('playerA');
            const playerB = document.getElementById('playerB');
            const masterVoiceSelect = document.getElementById('masterVoice');
            const rVoiceSelect = document.getElementById('rVoice');
            const nVoiceSelect = document.getElementById('nVoice');
            const legalFirstSelect = document.getElementById('legalFirst');
            const legalLastSelect = document.getElementById('legalLast');
            const newFirstSelect = document.getElementById('newFirst');
            const newLastSelect = document.getElementById('newLast');
            const nameSelects = [legalFirstSelect, legalLastSelect, newFirstSelect, newLastSelect];
            // --- End UI Elements ---

            // --- Base Audio File Definitions (NO PATHS) ---
            const recordingsBase = {
                r1: `R1.mp3`, r2: `R2.mp3`, r3: `R3.mp3`, r4: `R4.mp3`,
                r5: `R5.mp3`, r6: `R6.mp3`, r7: `R7.mp3`,
            };
            const allNameBaseFiles = [];
            for (let i = 1; i <= 10; i++) {
                allNameBaseFiles.push(`N${i}.mp3`);
            }
            // --- End Base Audio File Definitions ---

            // --- Populate Name Dropdowns ---
            function populateNameDropdowns() {
                nameSelects.forEach(select => {
                    select.innerHTML = '';
                    const randomOption = document.createElement('option');
                    randomOption.value = 'Random'; randomOption.textContent = 'Random'; randomOption.selected = true;
                    select.appendChild(randomOption);
                    allNameBaseFiles.forEach(baseName => {
                        const option = document.createElement('option');
                        option.value = baseName; option.textContent = baseName;
                        select.appendChild(option);
                    });
                });
            }
            populateNameDropdowns();
            // --- End Populate Name Dropdowns ---

            // --- State Variables ---
            let fileQueue = [];
            let currentTrackIndex = -1;
            let activePlayerElement = null;
            let isPlaying = false;
            // --- End State Variables ---

            /** Selects unique random BASE filenames. */
            function getRandomUniqueItems(array, count) {
                 if (count > array.length) { console.error("Not enough unique items..."); return []; }
                 if (count <= 0) return [];
                const shuffled = [...array].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }

             /**
              * Gets the correct ABSOLUTE path for a file based on voice selections.
              * @param {string} type - 'R' for R recordings, 'N' for N recordings.
              * @param {string} baseName - The base filename (e.g., "R1.mp3", "N5.mp3").
              * @returns {string} The absolute path (e.g., "/project1/1/R1.mp3").
              */
             function getFilePath(type, baseName) {
                const masterVoiceDir = masterVoiceSelect.value; // "1" or "2"
                const rVoiceDir = rVoiceSelect.value; // "Master", "1", or "2"
                const nVoiceDir = nVoiceSelect.value; // "Master", "1", or "2"

                let finalVoiceDir = masterVoiceDir; // Default to master voice directory

                // Override with specific selection if not 'Master'
                if (type === 'R' && rVoiceDir !== 'Master') {
                    finalVoiceDir = rVoiceDir;
                } else if (type === 'N' && nVoiceDir !== 'Master') {
                    finalVoiceDir = nVoiceDir;
                }

                // *** Construct ABSOLUTE path from the root ***
                // Assumes your site structure is domain.com/project1/index.html etc.
                // Adjust "/project1/" if your base path is different.
                const basePath = "/project1/";
                const voicePath = finalVoiceDir + "/"; // e.g. "1/" or "2/"
                const fullPath = basePath + voicePath + baseName;

                // Log the generated path for debugging
                // console.log(`getFilePath(type=${type}, baseName=${baseName}) -> ${fullPath}`); // Optional: verbose log
                return fullPath;
             }

             // --- Stop and Reset Function ---
             function resetPlayback(finishedNaturally = false) {
                 console.log(`Resetting playback. Finished naturally: ${finishedNaturally}`);
                 isPlaying = false; playButton.disabled = false; activePlayerElement = null;
                 currentTrackIndex = -1; fileQueue = [];
                 try { if (!playerA.paused) playerA.pause(); playerA.removeAttribute('src'); playerA.load(); console.log("Player A reset."); } catch(e){ console.warn("Error resetting player A", e); }
                 try { if (!playerB.paused) playerB.pause(); playerB.removeAttribute('src'); playerB.load(); console.log("Player B reset."); } catch(e){ console.warn("Error resetting player B", e); }
                 if (finishedNaturally) { statusCurrentTrack.textContent = "Finished."; }
                 else if (statusCurrentTrack.textContent !== 'Idle' && !statusCurrentTrack.textContent.startsWith("Error")) { statusCurrentTrack.textContent = "Idle"; }
             }
             // --- End Stop and Reset Function ---


            // --- Core Playback Logic (No changes needed here) ---
            function playNextTrack() {
                currentTrackIndex++;
                console.log(`Attempting to play track index: ${currentTrackIndex}`);
                if (currentTrackIndex >= fileQueue.length) { console.log("Reached end of queue."); resetPlayback(true); return; }

                let playerToPlayNow = (activePlayerElement === playerA) ? playerB : playerA;
                let playerToPreload = (activePlayerElement === playerA) ? playerA : playerB;
                const fileToPlay = fileQueue[currentTrackIndex];
                if (!fileToPlay) { console.error(`Error: File path at index ${currentTrackIndex} is invalid.`); handleError(new Error(`Invalid file path at index ${currentTrackIndex}`), playerToPlayNow === playerA ? 'A' : 'B'); return; }
                const shortNameToPlay = fileToPlay.split('/').pop();

                // Preload
                const preloadTrackIndex = currentTrackIndex + 1;
                if (preloadTrackIndex < fileQueue.length) {
                    const fileToPreload = fileQueue[preloadTrackIndex];
                    if (fileToPreload) {
                        const shortPreloadName = fileToPreload.split('/').pop();
                        console.log(`Attempting to set player ${playerToPreload === playerA ? 'A' : 'B'}.src = "${fileToPreload}" for preload`);
                        playerToPreload.src = fileToPreload; playerToPreload.load();
                        console.log(`Preloading index ${preloadTrackIndex} (${shortPreloadName}) on player ${playerToPreload === playerA ? 'A' : 'B'}`);
                    } else {
                         console.warn(`File path at preload index ${preloadTrackIndex} is invalid.`);
                         try { if (!playerToPreload.paused) playerToPreload.pause(); playerToPreload.removeAttribute('src'); playerToPreload.load(); } catch(e) { console.warn("Error clearing preload player src", e); }
                    }
                } else {
                    console.log(`No track to preload on player ${playerToPreload === playerA ? 'A' : 'B'}, clearing src.`);
                     try { if (!playerToPreload.paused) playerToPreload.pause(); playerToPreload.removeAttribute('src'); playerToPreload.load(); } catch(e) { console.warn("Error clearing preload player src", e); }
                }

                // Play
                console.log(`Attempting: ${playerToPlayNow === playerA ? 'A' : 'B'}.play() for ${shortNameToPlay} (Path: ${fileToPlay})`);
                statusCurrentTrack.textContent = shortNameToPlay;
                activePlayerElement = playerToPlayNow;

                const startPlayback = () => {
                    console.log(`Executing .play() for ${shortNameToPlay} on player ${activePlayerElement === playerA ? 'A' : 'B'}`);
                    const playPromise = activePlayerElement.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => { console.log(`Playback started successfully for ${shortNameToPlay}.`); })
                        .catch(error => { console.error(`Error from .play() promise for ${shortNameToPlay}:`, error); handleError(error, activePlayerElement === playerA ? 'A' : 'B'); });
                    } else { console.warn(".play() did not return a promise."); }
                };

                if (currentTrackIndex === 0) { console.log("Applying small delay before playing first track..."); setTimeout(startPlayback, 50); }
                else { startPlayback(); }
            }

            function handleTrackEnd(event) {
                 if (event.target === activePlayerElement) {
                     const playerName = (event.target === playerA) ? 'A' : 'B';
                     console.log(`Player ${playerName} ended (Track Index: ${currentTrackIndex}).`);
                     try { event.target.pause(); console.log(`Player ${playerName} explicitly paused.`); }
                     catch (e) { console.warn(`Could not pause player ${playerName}`, e); }
                     playNextTrack();
                 } else { /* Ignore ended event for inactive player */ }
            }
            playerA.addEventListener('ended', handleTrackEnd);
            playerB.addEventListener('ended', handleTrackEnd);

             function handleError(errorEvent, playerName) {
                 console.error(`Audio Error Event on Player ${playerName}:`, errorEvent);
                 let specificError = 'Unknown playback error';
                 if (errorEvent && errorEvent.target && errorEvent.target.error) {
                     const mediaError = errorEvent.target.error;
                     switch (mediaError.code) {
                         case mediaError.MEDIA_ERR_ABORTED: specificError = 'Playback aborted.'; break;
                         case mediaError.MEDIA_ERR_NETWORK: specificError = 'Network error loading audio.'; break;
                         case mediaError.MEDIA_ERR_DECODE: specificError = 'Audio decoding error.'; break;
                         case mediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: specificError = 'Audio source not supported or not found.'; break;
                         default: specificError = `Unknown error code ${mediaError.code}.`;
                     }
                     console.error(`MediaError code: ${mediaError.code}, message: ${mediaError.message || '(no message)'}`);
                 } else if (errorEvent instanceof Error) { specificError = errorEvent.message; }
                 const errorIndex = (currentTrackIndex >= 0) ? currentTrackIndex : 0;
                 const fileWithError = (errorEvent?.target?.src) || fileQueue[errorIndex] || 'Current/Starting file';
                 // Display the error using the full path attempted, if available
                 const displayPath = (errorEvent?.target?.src) ? errorEvent.target.src : fileWithError.split('/').pop();
                 statusCurrentTrack.textContent = `Error on ${displayPath}: ${specificError} Resetting.`;
                 resetPlayback();
             }
             playerA.addEventListener('error', (e) => handleError(e, 'A'));
             playerB.addEventListener('error', (e) => handleError(e, 'B'));
            // --- End Playback Logic ---


            // --- Event Listener for the Play Button (No changes needed here from previous version) ---
            playButton.addEventListener('click', () => {
                if (isPlaying && playButton.disabled) { console.warn("Playback process already running."); return; }
                resetPlayback();
                isPlaying = true;
                playButton.disabled = true;
                statusCurrentTrack.textContent = 'Processing selections...';
                statusSelectedNames.textContent = '...';

                // Determine Required BASE Name Files
                const nameSelections = nameSelects.map(s => s.value);
                const finalBaseNameFiles = [];
                const manualBaseNameSelections = nameSelections.filter(val => val !== 'Random');
                const neededRandomCount = nameSelections.filter(val => val === 'Random').length;
                console.log("Manual Base Name Selections (duplicates allowed):", manualBaseNameSelections);
                const uniqueManualBaseNames = [...new Set(manualBaseNameSelections)];
                let availableForRandom = [...allNameBaseFiles];
                uniqueManualBaseNames.forEach(manualBaseName => { availableForRandom = availableForRandom.filter(f => f !== manualBaseName); });
                console.log("Base names available for random selection:", availableForRandom);
                if (neededRandomCount > availableForRandom.length) {
                     console.error("Not enough unique base names..."); statusCurrentTrack.textContent = `Error: Not enough unique names available...`; resetPlayback(); return;
                }
                const randomSelections = getRandomUniqueItems(availableForRandom, neededRandomCount);
                console.log("Random base names selected:", randomSelections);
                let randomCounter = 0;
                for (const selection of nameSelections) { finalBaseNameFiles.push(selection === 'Random' ? randomSelections[randomCounter++] : selection); }
                console.log("Final base name files chosen for slots:", finalBaseNameFiles);
                const legalBaseName1 = finalBaseNameFiles[0]; const legalBaseName2 = finalBaseNameFiles[1];
                const newBaseName1 = finalBaseNameFiles[2]; const newBaseName2 = finalBaseNameFiles[3];

                statusSelectedNames.textContent = `Legal: (${legalBaseName1} + ${legalBaseName2}), New: (${newBaseName1} + ${newBaseName2})`;

                // Construct the FULL PATH playback queue using getFilePath
                 fileQueue = [
                    getFilePath('R', recordingsBase.r1), getFilePath('R', recordingsBase.r2), getFilePath('R', recordingsBase.r3),
                    getFilePath('N', legalBaseName1), getFilePath('N', legalBaseName2),
                    getFilePath('R', recordingsBase.r4), getFilePath('N', newBaseName1), getFilePath('N', newBaseName2),
                    getFilePath('R', recordingsBase.r5), getFilePath('N', newBaseName1), getFilePath('N', newBaseName2),
                    getFilePath('R', recordingsBase.r6), getFilePath('N', legalBaseName1), getFilePath('N', legalBaseName2),
                    getFilePath('R', recordingsBase.r7)
                ];
                currentTrackIndex = -1; // Reset index
                console.log('Constructed FULL PATH File Queue:', fileQueue); // Log the final paths

                // Start Playback Sequence
                if (fileQueue.length > 0) {
                    statusCurrentTrack.textContent = `Starting...`;
                    const firstFile = fileQueue[0]; // Should be absolute path e.g., "/project1/1/R1.mp3"
                    if (firstFile) {
                        console.log(`Attempting to set playerA.src = "${firstFile}"`);
                        playerA.src = firstFile; playerA.load();
                        console.log(`Initial load (Track 0): ${firstFile} on Player A`);
                    } else { console.error("Invalid first file."); statusCurrentTrack.textContent = "Error: Invalid first file."; resetPlayback(); return; }

                    if (fileQueue.length > 1) {
                        const secondFile = fileQueue[1];
                        if (secondFile) {
                            console.log(`Attempting to set playerB.src = "${secondFile}"`);
                            playerB.src = secondFile; playerB.load();
                            console.log(`Initial preload (Track 1): ${secondFile} on Player B`);
                        } else { console.warn("Invalid second file."); playerB.removeAttribute('src'); playerB.load(); }
                    } else { console.log("Only one track."); playerB.removeAttribute('src'); playerB.load(); }

                    activePlayerElement = playerB; // Pretend B finished
                    console.log("Calling playNextTrack to start sequence...");
                    playNextTrack(); // Start the sequence

                } else { console.log("File queue empty."); statusCurrentTrack.textContent = "No files to play."; resetPlayback(); }
            }); // --- End Button Click Listener ---

        }); // End DOMContentLoaded
    </script>

</body>
</html>

